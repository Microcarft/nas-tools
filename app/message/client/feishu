import json
from threading import Lock
import requests
from app.message.client._base import _IMessageClient
from app.utils import ExceptionUtils
from config import Config

lock = Lock()

class Feishu(_IMessageClient):
    schema = "feishu"

    _client_config = {}
    _domain = None
    _url = None
    _method = None
    _query_params = None
    _json_body = None
    _token = None

    def __init__(self, config):
        self._config = Config()
        self._client_config = config
        self.init_config()

    @classmethod
    def __parse_json(cls, json_str, attr_name):
        json_str = json_str.strip()
        if not json_str:
            return None
        try:
            return json.loads(json_str)
        except json.JSONDecodeError as e:
            raise ValueError(f"{attr_name} Json解析失败：{json_str}") from e

    def init_config(self):
        if self._client_config:
            self._url = self._client_config.get("url")
            self._method = self._client_config.get("method")
            self._query_params = self.__parse_json(self._client_config.get("query_params"), 'query_params')
            self._json_body = self.__parse_json(self._client_config.get("json_body"), 'json_body')
            self._token = self._client_config.get("token")

    @classmethod
    def match(cls, ctype):
        return True if ctype == cls.schema else False

    def send_msg(self, title, text="", image="", url="", user_id=""):
        """
        发送web请求
        :param title: 消息标题
        :param text: 消息内容
        :param image: 消息图片地址
        :param url: 点击消息转转的URL
        :param user_id: 用户ID，如有则只发消息给该用户
        :user_id: 发送消息的目标用户ID，为空则发给管理员
        """
        if not title and not text:
            return False, "标题和内容不能同时为空"
        if not self._url:
            return False, "url参数未配置"
        if not self._method:
            return False, "method参数未配置"
        try:
            # 构建飞书自定义机器人的请求体
            json_body = {
                "msg_type": "text",
                "content": {
                    "text": f"{title}\n{text}"
                }
            }
            headers = {"Content-Type": "application/json"}
            if self._token:
                headers['Authorization'] = self._token

            response = requests.post(self._url, headers=headers, json=json_body)
            if response.status_code == 200:
                return True, "消息发送成功"
            else:
                return False, f"消息发送失败，状态码：{response.status_code}"

        except Exception as e:
            ExceptionUtils.exception_traceback(e)
            return False, str(e)

    def send_list_msg(self, medias: list, user_id="", title="", **kwargs):
        """
        发送列表类消息
        """
        if not title:
            return False, "title为空"
        if not medias or not isinstance(medias, list):
            return False, "medias错误"
        if not self._url:
            return False, "url参数未配置"
        if not self._method:
            return False, "method参数未配置"
        if self._method == 'GET':
            return False, "GET不支持发送发送列表类消息"
        try:
            articles = [{
                "title": media.get_title_string(),
                "description": media.get_vote_string() or "",
                "picurl": media.get_message_image() if index == 1 else media.get_poster_image(),
                "url": media.get_detail_url()
            } for index, media in enumerate(medias, start=1)]

            json_body = {
                "msg_type": "news",
                "content": {
                    "news": {
                        "articles": articles
                    }
                }
            }
            headers = {"Content-Type": "application/json"}
            if self._token:
                headers['Authorization'] = self._token

            response = requests.post(self._url, headers=headers, json=json_body)
            if response.status_code == 200:
                return True, "消息发送成功"
            else:
                return False, f"消息发送失败，状态码：{response.status_code}"

        except Exception as e:
            ExceptionUtils.exception_traceback(e)
            return False, str(e)
